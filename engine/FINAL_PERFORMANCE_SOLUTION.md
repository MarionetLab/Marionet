# ⚡ 终极性能解决方案

> **最终版本**: 1.2  
> **更新时间**: 2025-10-23  
> **性能**: 最大化优化

---

## 🎯 **问题诊断**

用户报告：即使每 10 帧检测一次（6 次/秒），仍然有明显卡顿。

**分析**：
```
每 10 帧 = 6 次/秒
2048×2048 RGBA 纹理 = 16MB
6 次 × 16MB = 96MB/秒 GPU → CPU 数据传输
```

**结论**：对于某些系统（尤其是高分辨率纹理），96MB/秒 的持续数据传输仍然会造成性能瓶颈。

---

## ✅ **最终解决方案**

### 核心改进

**检测频率：每 60 帧（1 次/秒）**

```csharp
frameCounter++;
if (frameCounter < 60)  // 每 60 帧
{
    return;
}
frameCounter = 0;
```

**效果**：
- GetImage() 调用：6 次/秒 → **1 次/秒** 🎯
- GPU → CPU 数据传输：96MB/秒 → **16MB/秒** 🎯
- **性能提升：6 倍** 🚀

---

## 📊 **性能对比（完整历史）**

| 版本 | GetImage() 频率 | GPU 传输量 | 性能 | 中键拖动 | 响应延迟 |
|------|-----------------|------------|------|----------|----------|
| **主动（每帧）** | 60 次/秒 | 960MB/秒 | ❌ 严重卡顿 | ✅ | 0ms |
| **主动（每5帧）** | 12 次/秒 | 192MB/秒 | ⚠️ 明显卡顿 | ✅ | 83ms |
| **混合（每10帧）** | 6 次/秒 | 96MB/秒 | ⚠️ 仍有卡顿 | ✅ | 166ms |
| **混合（每60帧）** | **1 次/秒** | **16MB/秒** | ✅ **流畅** | ✅ | ~1000ms |

---

## ⚖️ **权衡说明**

### 优势
- ✅ **性能最大化**：几乎不影响帧率
- ✅ **支持中键拖动**：鼠标在人物上时可以拖动
- ✅ **背景穿透**：鼠标在背景上点击穿透

### 劣势
- ⚠️ **响应延迟高**：最多 1 秒（约 60 帧）
  - 鼠标移到人物上 → 最多等待 1 秒 → 禁用穿透
  - 实际体验：如果用户移动鼠标后立即按中键，可能会失败（事件被穿透）

### 用户体验影响

**场景 1：用户快速移动鼠标并点击**
```
用户将鼠标移到人物上 → 立即按中键拖动
    ↓
如果刚好在检测间隔内（未检测到）
    ↓
窗口仍然是穿透状态
    ↓
中键事件被穿透 ❌
    ↓
1 秒后，系统检测到鼠标在人物上
    ↓
禁用穿透，现在可以拖动了 ✅
```

**建议**：用户需要等待约 1 秒，让系统检测到鼠标位置。

**场景 2：用户缓慢移动鼠标**
```
用户将鼠标移到人物上 → 等待 → 按中键拖动
    ↓
1 秒内，系统检测到鼠标在人物上
    ↓
禁用穿透
    ↓
按中键拖动 → 成功 ✅
```

---

## 🎨 **FPS 显示**

### 新增功能

**左上角 FPS 显示**：
- 绿色：≥ 50 FPS（流畅）
- 黄色：30-50 FPS（一般）
- 红色：< 30 FPS（卡顿）

### 实现

```gdscript
func _create_fps_label():
    fps_label = Label.new()
    fps_label.position = Vector2(10, 10)
    fps_label.add_theme_font_size_override("font_size", 16)
    add_child(fps_label)

func _update_fps_display(delta: float):
    frame_times.append(delta)
    if frame_times.size() > max_samples:
        frame_times.pop_front()
    
    var avg_delta = 0.0
    for frame_time in frame_times:
        avg_delta += frame_time
    avg_delta /= frame_times.size()
    
    var fps = 1.0 / avg_delta
    fps_label.text = "FPS: %.1f" % fps
```

---

## 🔥 **验证步骤**

### 1️⃣ 重新加载 Godot 项目

### 2️⃣ 运行项目 (F5)

### 3️⃣ 观察 FPS 显示（左上角）

**预期结果**：
- ✅ FPS 应该稳定在 55-60（绿色）
- ✅ 无明显卡顿
- ✅ CPU/GPU 占用低

### 4️⃣ 测试中键拖动

**步骤**：
1. 将鼠标移到人物上
2. **等待 1-2 秒**（让系统检测到）
3. 观察日志：`[MouseDetection] 鼠标移到人物上，禁用穿透`
4. 按住中键拖动窗口
5. 应该可以正常拖动 ✅

### 5️⃣ 测试背景穿透

**步骤**：
1. 将鼠标移到背景（不在人物上）
2. 点击 → 应该穿透到桌面 ✅

---

## 💡 **进一步优化建议**

### 如果性能仍然不够好

#### 选项 1：减小 SubViewport 分辨率
```gdscript
# 在场景中设置
sub_viewport.size = Vector2i(1024, 1024)  # 而不是 2048x2048
```

**效果**：
- 纹理大小：16MB → **4MB**
- GetImage() 时间：~10ms → **~2.5ms**
- 4 倍性能提升

#### 选项 2：进一步降低检测频率
```csharp
if (frameCounter < 120)  // 每 120 帧（0.5 次/秒）
```

**效果**：
- 检测频率：1 次/秒 → **0.5 次/秒**
- 响应延迟：~1000ms → **~2000ms**

#### 选项 3：完全禁用主动检测
```gdscript
# 在需要拖动时，手动禁用穿透
func _input(event):
    if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_MIDDLE:
        if event.pressed:
            # 中键按下，立即检测一次
            var window_service = ServiceLocator.get_service("WindowService")
            if mouse_detection_service.IsPositionClickable(event.position, sub_viewport):
                window_service.SetClickThrough(false)
```

---

## 🚨 **如果 FPS 仍然很低**

### 可能的原因

1. **其他性能问题**
   - Live2D 模型过于复杂
   - 眼动追踪计算量大
   - 动画系统耗时

2. **GPU 瓶颈**
   - 高分辨率纹理（2048x2048）
   - 复杂的渲染管线

3. **CPU 瓶颈**
   - GDScript 脚本执行慢
   - 过多的节点更新

### 诊断方法

**使用 Godot 性能分析器**：
```
调试 (Debug) → 性能分析器 (Profiler)
```

查看：
- **Process Time**：哪个函数耗时最多？
- **Physics Process Time**：物理处理是否太慢？
- **Rendering**：渲染是否是瓶颈？

---

## 📝 **最终建议**

### 对于用户

**使用建议**：
1. 将鼠标移到人物上
2. **等待 1-2 秒**（看到日志：`鼠标移到人物上，禁用穿透`）
3. 再按中键拖动

### 对于开发者

**如果响应延迟不可接受**，考虑：
1. **方案 A**：使用更小的纹理（1024x1024）
2. **方案 B**：只在中键按下时检测一次（不主动检测）
3. **方案 C**：使用更简单的碰撞检测（不用像素检测）

---

## 🎯 **当前状态**

| 指标 | 值 |
|------|-----|
| **检测频率** | 1 次/秒（每 60 帧） |
| **GPU 传输量** | 16MB/秒 |
| **预期 FPS** | 55-60（流畅） |
| **中键拖动** | 支持（延迟 ~1 秒） |
| **背景穿透** | 支持 |
| **点击动画** | 支持 |

---

**请测试并告诉我 FPS 是否正常！** 📊

如果左上角显示的 FPS 稳定在 55-60（绿色），说明性能问题已解决！

如果 FPS 仍然很低（< 30），请告诉我，我们需要找其他性能瓶颈。

